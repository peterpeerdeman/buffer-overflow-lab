use std::result::Result;
use clap::error::Error as ClapError;

pub fn return_address_parser(return_address: &str) -> Result<u32, ClapError> {
    if return_address.len() != 8 {
        return Err(ClapError::raw(
            clap::error::ErrorKind::ValueValidation,
            "return address should have length of 8",
        ));
    }
    let decoded: Vec<u8> = hex::decode(return_address.to_string()).unwrap();
    let byte_array: [u8; 4] = decoded.try_into().expect("something went wrong");
    let u32_return_address = Some(u32::from_le_bytes(byte_array)).unwrap();
    Ok(u32_return_address)
}
